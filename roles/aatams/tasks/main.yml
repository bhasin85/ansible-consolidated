
  # assumes postgres already setup
  - apt: name=tomcat7 update_cache=yes

  # paths
  - set_fact: tomcat7=/var/lib/tomcat7
  - set_fact: conf={{tomcat7}}/conf
  - set_fact: webapps={{tomcat7}}/webapps
  - set_fact: lib={{tomcat7}}/lib
  - set_fact: log=/var/log/tomcat7
  - set_fact: aatams_data={{conf}}/aatams-data

  # permissions
  - file: path={{item}} state=directory owner=tomcat7 group=tomcat7
    with_items:
      - "{{tomcat7}}"
      - "{{webapps}}"
      - "{{lib}}"
      - "{{aatams_data}}"

  # change log-file permissions
  - file: path={{log}}/catalina.out mode=0666

  # use apache/ubuntu connection pool jar. commons has bug, probably class loader
  # related, where pool throws on class load failre of Cursor
  - copy:
      dest: "{{lib}}/tomcat-dbcp.jar"
      src: tomcat-dbcp.jar
      owner: tomcat7
      group: tomcat7

  # tomcat
  - copy:
      dest: /etc/default/tomcat7
      backup: yes
      owner: tomcat7
      group: tomcat7
      content: |
        # deployed by ansible!
        TOMCAT7_USER=tomcat7
        TOMCAT7_GROUP=tomcat7
        JAVA_OPTS="${JAVA_OPTS} \
          -Xmx4081m -Xms512m -server -XX:MaxPermSize=256m -XX:+HeapDumpOnOutOfMemoryError \
          -Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n"
    notify: restart-tomcat7

  # jndi
  # factory="org.apache.commons.dbcp.BasicDataSourceFactory"
  - copy:
      dest: "{{conf}}/context.xml"
      backup: yes
      owner: tomcat7
      group: tomcat7
      content: |
        <?xml version='1.0' encoding='utf-8'?>
        <!-- deployed by ansible! -->
        <Context>
            <!-- Default set of monitored resources -->
            <WatchedResource>WEB-INF/web.xml</WatchedResource>
            <Resource
                name="jdbc/aatams"
                auth="Container"
                factory="org.apache.tomcat.dbcp.dbcp.BasicDataSourceFactory"
                type="javax.sql.DataSource"
                driverClassName="org.postgresql.Driver"
                url="{{aatams.jndi.url}}"
                validationQuery="SELECT 1"
                username="{{aatams.jndi.username}}"
                password="{{aatams.jndi.password}}"
                maxActive="20" maxIdle="5" maxWait="-1"
                testOnBorrow="true" testWhileIdle="true" testOnReturn="true"
                timeBetweenEvictionRunsMillis="30000"
                numTestsPerEvictionRun="3"
                minEvictableIdleTimeMillis="60000"
                defaultAutoCommit="false"
            />
            <Environment name="aodn.configuration" value="{{aatams_data}}/aatams.groovy" type="java.lang.String" override="true"/>
        </Context>
    notify: restart-tomcat7

  # NOTE: currently a template, but perhaps should do inline using copy module
  # grails config
  - template: >
      src=aatams.groovy.j2
      dest={{aatams_data}}/aatams.groovy
      owner=tomcat7
      group=tomcat7
    notify: restart-tomcat7

  # war
  # TODO owner - use file?
  - get_url: >
      url=https://jenkins.aodn.org.au/job/aatams_prod/lastSuccessfulBuild/artifact/target/aatams-3.16.0.war
      dest=/var/lib/tomcat7/webapps/aatams.war
    notify: restart-tomcat7

  # TODO factor this out into a separate task?
  # should be role and task, and not a role, to be included
  # actually should be able to call as a role, but specifying the path



#  - apt: name=python-psycopg2
#
#  - postgresql_user: name=aatams
#    become: true
#    become_user: postgres
#
#  - postgresql_db: name=aatams owner=aatams
#    become: true
#    become_user: postgres
#
#  - postgresql_ext: db=aatams name=postgis
#    become: true
#    become_user: postgres

    # ok, now we just need schema and searchpath and admin.sql ....

    # instead of running commands... would it be easier to create an sql script and run it wholesale?
    # can then be idempotent as against the file...

    # script is nicer permits multiple commands...

  - copy:
      dest: /ansible/xxx.sql
      content: |
        -- deployed by ansible3
        drop database if exists {{aatams.postgres.database}};
        drop user if exists {{aatams.postgres.username}};
        create user {{aatams.postgres.username}} unencrypted password '{{aatams.postgres.username}}';
        create database {{aatams.postgres.database}} owner {{aatams.postgres.username}};
        \c aatams
        create extension postgis;
        create schema aatams authorization {{aatams.postgres.username}};
        alter database aatams set search_path to 'aatams','public';
    register: whoot


  - shell: psql -f /ansible/xxx.sql
    become: yes
    become_user: postgres
    when: whoot.changed == true


  # check for existing aatams database
  - shell: psql -tAc "select 1 from pg_database where datname='aatams'"
    become: yes
    become_user: postgres
    register: have_aatams_db
    changed_when: false

  # create fresh database if none
  - shell: "{{item}}"
    become: yes
    become_user: postgres
    when: have_aatams_db.stdout != "1"
    with_items:
      - |
        psql -d postgres -c "
          drop user if exists aatams;
          create user aatams unencrypted password 'aatams';
          "
      - psql -d postgres -c "create database aatams owner aatams"
      - |
        psql -d aatams -c "
          create extension postgis;
          create schema aatams authorization aatams;
          alter database aatams set search_path to 'aatams','public';
          "
      # this is horrible cross-role dependency....
      - psql -d aatams -f /usr/share/postgresql/9.4/admin.sql

